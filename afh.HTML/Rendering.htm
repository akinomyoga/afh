<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:afh="http://www.example.com/afh/">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<link rel="stylesheet" type="text/css" href="mwg.std.css" />
<title>afh.Rendering 実装に関するメモ</title>
<style type="text/css">
.obsolete{color:gray;}
strong{font-weight:normal;}

table.table1{}
table.table1 td{padding:3px;}
table.table1 th{padding:3px;background-color:#eee;}

afh\:yotei{color:#088;}
</style>
</head>
<body>
<h1>afh.Rendering.FontSize</h1>
<!--========================-->
<h2>ピクセルを基準にする事</h2>
<p>FontSize の内部表現では、物理的な長さではなく、ピクセルを以て長さを表現する事にした。
この事によって、物理的な長さ (メートル法など) を扱う際には色々と問題が出て来るかも知れない。
その、問題点に関して考察...</p>
<h3>利点</h3>
<p>そのまま Graphics を使用して描画する事が可能。</p>
<h3>欠点</h3>
<p class="obsolete">印刷の際にとても小さく印刷されてしまう可能性がある。</p>
<p class="obsolete">→本当か? 実はちゃんと調整してくれるのかも知れない。</p>
<p>→印刷の際に変な大きさになっても大丈夫な様に、後で units を差し替える事が出来る様な仕組みにした。
(具体的には、units の要素に適当に数字を掛けて根の UpdateUnits を呼び出せば良い。)</p>
<!--========================-->
<h2>解像度の変更に関して</h2>
<ol style="list-style-type:upper-alpha;">
<li class="obsolete">Length chain を作って解像度に関する情報を共有
 <ul>
 <li>device に従ってその共有している情報を変更すればよい</li>
 <li>×共有している情報が変化したという事をどの様に検知するのか?
  <ul>
  <li>→変更した側が再描画などを要求する<br />
  　これは、どうせ親 Length を変更した際にも付きまとう問題であるので、その対応の際に一緒に考えればよい。</li>
  <li>→フォントの場合には、実際に使用する際に変更が行われていないか一々確認する様にする?<br />
  　→version を使用する?...何れにしても確認をする必要がある事に変わりはない。</li>
  </ul>
 </li>
 </ul>
</li>
<li>Length chain で文字通りに parent から child への参照を保持して変更があった場合には<a href="#fontsize.下達">下達する仕組み</a>にする。
 <ul>
 <li>○この様にすれば親 Length の値に依存している物の変更のタイミングも把握する事が出来る。というか、その場で直ぐに変更する。</li>
 <li>×描画中に頻繁に親 Length が変更される様なら、この様に何度も変更するよりは、使用する際に親を辿って計算すればよい。<br />
 　→○然し、その様な事はないと思われるので、この方法でよい。
 </li>
 <li>○この方法ならば使用する際に一々計算をやり直す必要はない。</li>
 </ul>
</li>
</ol>
<p>B. を採用する事に決定する</p>
<!--========================-->
<h2 id="fontsize.下達">変更の下達の仕組み</h2>

<p>単に parent の大きさが変化して、それに応じて子の % 参照や em/ex 参照を更新しなければならない時</p>
<ol>
<li>Pixels に値を設定 (設定は内部的にしか行えない)</li>
<li>子の UpdateParent を呼び出し</li>
<li>この際に、子の Pixels が設定されれば、1. に戻って同様にして孫へと変更が伝播していく</li>
</ol>

<p>dpi を変更して全面的に大きさを再計算しなければならない時</p>
<ol>
<li>Dpi に値を設定 (これは外部から設定可能)</li>
<li>UpdateUnits を介して値の変更が適用される。</li>
<li>更に、子 FontSize が存在していればそれぞれに対して、UpdateUnits が呼び出され、変更が伝播されていく</li>
</ol>

<h2>外部からの、文字列による値の変更に関して</h2>
<p>外部から値を変更しようとした場合に、典型的に考えられるのは、文字列による設定である。
この場合に、文字列を解釈して新しい FontSize インスタンスを作成する方法がある。
然し、この様にすると、font-size chain が構成された後の値の変更で困難を生ずる。
古いインスタンスを chain から削除し、新しく文字列から生成したインスタンスを chain に組み込まなければならないのである。
そこで、新しい FontSize インスタンスを生成させずに、現状のインスタンスの値を変更する仕組みが必要である。</p>
<p>→void Parse(string) を実装。既存の static FontSize Parse(string,FontSize) はこのインスタンスメソッドを呼び出す形式に変更。</p>
<!--========================-->
<h2>局所相対長さ %, ex, em について</h2>
<table class="normal">
<tr><th /><th>font-size の場合</th><th>その他の場合</th></tr>
<tr><th>% の基準</th>
	<td>親要素の font-size</td><td>親要素の大きさ</td></tr>
<tr><th>ex/em の基準</th>
	<td>親要素の font-size</td><td>自分の font-size</td></tr>
</table>
<pre>
 ┌ Parent Element ──┐┌ Child Element  ───┐
 │font-size: Length ←┼┼(e/%) font-size:Length│
 │width/height      ←┼┼      └(e) 他        │
 └──────────┘└───────────┘
</pre>
<p>結論:</p>
<ul>
<li>font-size 用の Length と他の物の為の Length は別の実装にするべきである。</li>
<li>このクラスを Length から FontSize に改名する。
	<p>然し、多くの部分は Length にも適用出来る。
	実際の所異なるのは、この「局所相対長さ」の部分のみである。
	則ち、font-size chain の管理部分だけが、通常の length の場合と異なるのみである。</p>
</li>
</ul>
<!--========================-->
<h2>Chain への挿入に関して</h2>
<p>Chain への挿入を行いたくなった場合に、現在の仕組みでは致命的である。
Chain への挿入を行う際には、parent と child の間に挟めばよいだけと考えられるかも知れないが、
parent からは多くの分岐が考えられる。どの分岐に挿入するのが適当なのかを判断するのは、とても面倒である。
DrawUnit 自体の tree を辿って自分が含まれているか否か、child のいずれかが含まれているかを一つ一つ確認しなければならない為である。</p>
<p>茲で、挿入が行われるような状況に関して考えてみる。
先ず DrawUnit 甲, 乙, 丙 が以下のようになっている場合を考える。
この場合に、乙の描画では fsize甲 が使用される事になっている。
</p>
<pre>
甲 → fsize甲
↓      │
乙      │
↓      ↓
丙 → fsize丙
</pre>
<p>所が、新しく乙を異なった fsize で描画したくなった場合に、fsize甲 と fsize丙 の間に挿入が必要となる。
この挿入で、考えるべき所は、挿入が「DrawUnit へ新しく fsize を適用する」という視点から行われている点である。
良く考えてみれば、DrawUnit の構造を無視して新しく FontSize が挿入されるような状況は考えがたい。</p>

<h3>DrawUnit の Chain を利用</h3>
<p>Chain は FontSize で独自に形成するのではなく DrawUnit を単位にして行うべきではないか?
上で見たように、現在の実装に於いては、FontSize chain と DrawUnit chain が乖離している。
FontSize chain は DrawUnit chain に任せるべきなのかも知れない…という事に関して考えてみる。</p>

<ol>
<li>FontSize chain を無くし DrawUnit chain に任せた場合の問題点
	<ul>
	<li>parent → child の参照が困難
	 <p>parent → child の参照は、parent の FontSize の変化を child に伝える際に必要である。之によって、% 指定や em/ex 指定の更新が可能になる。</p>
	 <p>child → parent の場合には、DrawUnit の parent を辿って style を検索していけばよい。
	 然し、parent → child の場合には、抑も child が存在するのかどうかも分からないし、DrawUnit に従って分岐していく先を全て検索しなければならない。
	 </p>
	 <p>Parent がイベントを発行して、それを child が受け取るという方法にすればよい。その参照は child の方で管理を行う事が出来る。
	  然し、それならば、イベントを登録する変わりに parent の用意したリストに child が自分自身を登録・解除する仕組みと同じである。
	  overhead を考えれば、寧ろ自分自身を登録する仕組みの方がよい。
	 </p>
	</li>
	<li>速度が遅くなるのではないかという心配…我慢する…大きなプログラムを書く時には止むを得ない現実である。
	高速化は完成してから考える or リファクタリングの際に考える事にする。
	</li>
	</ul>
</li>
<li>FontSize の chain と DrawUnit の chain を併用する事。
	 <p>つまり、基本的には今迄と同じである。然し、DrawUnit chain と FontSize chain を上手に組み合わせる事が出来るように多少の変更を考える。
	 尚、これから Length の chain も必要になる事は必至であるので、FontSize と Length とで共通すると思われる部分は基本クラスで実装させる事にする。</p>
	 <ul>
	 <li>変更の伝達は基本クラスの em_norm/percent_norm を通じて行う。リスナーは child_em/child_perc に登録する。</li>
	 <li>上の様にすると自然に parent → child の参照が出来る。
	 然し、この場合には二本の chain が出来上がっているのでそのどちらを使用するかを考えなければならない。
	  <ul>
	  <li>但し、どちらかを使用すると言っても挿入などの操作の場合には、勿論どちらも変更を行うべきである。</li>
	  <li>どちらを使用するかは、chain の構築の仕方で観察するのがよい。</li>
	  <li>FontSize の場合には em/% はどちらも同じ構造になるはずであるので考慮しなくても良い。</li>
	  </ul>
	 </li>
	 </ul>
</li>
</ol>

<h3>各 Length の chain 形成パターン</h3>
<p>Length chain の作り方を考える上では、各 length によって異なる、chain の形成パターンについても見ておかなければならない。</p>
<table class="normal">
<tr><th>種類</th><th>css-attribute</th><th>% 系列</th><th>em/ex 系列</th></tr>
<tr><td>FontSize</td><td>font-size</td>
	<td>最も近い先祖の font-size</td>
	<td>最も近い先祖の font-size</td>
	</tr>
<tr><td>width 系列</td>
	<td>width<br />margin-left<br />margin-right<br />padding-left<br />padding-right<br />border-left<br />border-right<br />
	min-width<br />max-width<br />top<br />bottom</td>
	<td>包含ブロックの width</td>
	<td>自分の font-size<br />なければ最も近い先祖の font-size</td>
	</tr>
<tr><td>height 系列</td>
	<td>height<br />margin-top<br />margin-bottom<br />padding-top<br />padding-bottom<br />border-top<br />border-bottom<br />
	min-height<br />max-height<br />left<br />right</td>
	<td>包含ブロックの height</td>
	<td>自分の font-size<br />なければ最も近い先祖の font-size</td>
	</tr>
</table>
<p>「最も近い先祖」は Style の検索によって容易に実現が可能である。</p>

<h3>挿入方法の案</h3>
<ol style="list-style-type:lower-alpha;">
<li>FontSize
	<ol>
	<li>挿入先の要素を E1 とする。E1 の親を辿っていき一番最初に当たった font-size を持つ先祖を P とする。</li>
	<li>P の保持する child_em/child_perc の子供達を C1, C2, C3 ... とする。</li>
	<li>Cn のそれぞれから、親を辿っていき、E1 か P に辿り着くまでそれを繰り返す。
	E1 に辿り着いた場合には P の child_** から除去し、E1 の child_** に登録する。
	P に辿り着いた場合には何もしない。</li>
	</ol>
</li>
<li>Width 系列
	<p>child_em に関しては font-size と同様に処理する。但し、探索は E1 自身から始める。</p>
	<ol>
	<li>挿入先の要素を E1 とする。E1 の親を辿っていき一番最初に当たった font-size を持つ先祖を P とする。</li>
	<li>P の保持する child_em/child_perc の子供達を C1, C2, C3 ... とする。</li>
	<li>Cn のそれぞれから、親を辿っていき、E1 か P に辿り着くまでそれを繰り返す。
	E1 に辿り着いた場合には P の child_** から除去し、E1 の child_** に登録する。
	P に辿り着いた場合には何もしない。</li>
	</ol>
</li>
</ol>
<!--========================-->
<h2>Chain の大きさの問題</h2>
<p>chain を形成する事にすると、値の検索は早くなると考えられるが、
stylesheet 要素で一括に指定された場合、その要素が沢山あった日にはメモリを沢山食う事になってしまう。</p>
<pre class="cs">
class Length{
	// ptr = 4/8B :型情報

	float number;       // 4B
	LengthUnit unit;    // 4B
	float[] units;      // ptr = 4/8B (配列本体は共有)
	float pixel;        // 4B
	
	float em_norm;      // 4B
	float percent_norm; // 4B
	List child_em;      // ptr*8~ = 32/64~ B
	List child_perc;    // ptr*8~ = 32/64~ B
	
	// ★ptr*8 の内訳
	//   List への参照
	//   List 自身の型
	//   List のコンテナ配列への参照
	//   List のコンテナ配列自身の型
	//   List の初期コンテナサイズ = 4
}
</pre>
<p>現状では field は上の様になっているので、32bit 環境では少なくとも <strong>92B</strong>, 64bit 環境では少なくとも <strong>148B</strong> にはなると考えられる。
構成の方法を一から考え直した方が良い様に思われてきた...新しく作る場合にどの様にするかを考えてみる事にする。</p>
<ul>
<li>Length を分割して、重複がない様にする。つまり、&gt;stylesheet&lt; の中の font-size は number/unit だけを保持し、
それを適用した先の各要素で実際の長さである pixel を保持すればよい。
要素単位で inline-stylesheet が設定されている場合には、その要素で number/unit 構造と pixel を保持していればよい。</li>
<li>number/unit を class/struct Length として保持する (実は、参照の大きさ的に直接保持した方が経済的かも知れない...)。
亦、pixels はそれぞれの要素の style に格納してしまう事にすればよい。</li>
<li>units は全体で共有する事にする。画面が複数ある場合でも気にしない事にするのである。</li>
</ul>
<p>親子関係の保持についてはもう少し考えてみなければならない。
一番大きさを食っているのが親子関係である。親が子の情報を保持しているという点が最も悪い。
親が子の情報を保持している事の利点は、親の変更に伴って子をその場で変更する事が出来るという点にある。
親子関係として、現在考え得る物は以下の様な物達である:
</p>
<ol style="list-style-type:lower-alpha;">
<li>若し、その場で変更しないという事になると、レンダリングの度に子から親を探しに行って値を計算する必要が出て来る。
	然し、この事によってレンダリングが重くなってしまう事は避けたい (唯でさえ重いのだから…)。
	実際にどれだけレンダリングが重くなるのかは試してみた訳ではないので分からない。
	然し、実際に殆ど影響がなかったとしても、もう少し良い方法を考えてみたい物である。
	<ul>
	<li>○ 値の変更時に何もしなくて良い。</li>
	<li>× レンダリング時に、親を全て辿って値を計算し直す必要がある。(然も子孫の node の数だけ重複して計算)</li>
	</ul>
	<br />
</li>
<li>もう一つの方法は、親子関係を持たずに、その場で変更を適用するという方法である。
	つまり、変更に際しては一々子要素を検索して行って、自分を参考にして決められるべき物を発見したら再計算をさせるという仕組みである。
	抑も、値が変更される様な状況は滅多にないと考えればこの方法でもさして問題ではない。
	この場合の要素の構造は不要である。則ち float pixel だけで良く、この大きさは <strong>4B</strong> に過ぎない。
	<p>然し、根っこの font-size を変えた場合には、最悪の場合全ての要素に対して探索を行う事になる。
	その様な事を防ぐ為には、やはり下で述べた様な方法の方が良いのかも知れない。
	(と思ったが、下の方法を使うと version 問い合わせで連鎖が起こって結局上の方法と変わりない様だ…やはりこっちの方が良い。)</p>
	<ul>
	<li>○ レンダリング時に何もしなくて良い。</li>
	<li>× 値の変更時には、殆どの場合全ての子孫 node を回って値の変更を適用しなければならない。</li>
	</ul>
	<br />
</li>
<li>更にもう一つ方法がある。子が、親への参照及び version を保持するという物である。
	この方法を使うと、それぞれの LengthChain 要素は以下の様になり、この大きさは ptr*3+16 = <strong>28/40B</strong> である。
<pre class="cs">
class LengthChainElem{
	LengthChainElem parent_em;
	LengthChainElem parent_pct;
	
	int version_em;
	int version_pct;
	
	float pixel;
	
	int version;
}
</pre>
	<p>×然し、この場合でもレンダリングの際には毎回 version を親に問い合わせなければならない。
	その際に、更に親は祖父に version の問い合わせを行う必要が生じる。この調子で行くと<strong>結局全て計算し直す方法と余り変わらない</strong>事になる。
	これを少し改良した下の版でも同じ問題が生ずる。</p>
	<ul>
	<li>○ 値の変更時に version++ するだけで良い。</li>
	<li>× レンダリング時に、親を全て辿って version を比較する必要がある。</li>
	</ul>
	<br />
</li>
<li>更に、上の場合にはもっと容量を減らす事が出来る。
<pre class="cs">
class LengthChainElem{
	LengthChainElem parent;
	int p_version;
	
	float pixel;
	int version;
}
</pre>
	<p>以上の様な構造にして、unit が em/ex の場合には em/ex の親を指定し、unit が % の場合には % の親を保持するという管理方法である。
	単位がそれ以外の場合には、parent と p_version の field は使用しない。
	使用しない場合には、もう少し小さな構造体を用意すると良いという考え方もあるが、その両方に対応する為のコードが冗長になるので止めておく。
	(継承を使うという手もあるかも知れないが、そうすると逆にデータ量が大きくなってしまうので使用しない。)</p>
	<p>この場合には、ptr*2+12 = <strong>20/28B</strong> である。</p>
	<ul>
	<li>○ 値の変更時に version++ するだけで良い。</li>
	<li>× レンダリング時に、親を全て辿って version を比較する必要がある。</li>
	</ul>
	<br />
</li>
<li>さて、上の二つの方法で問題が生じた。この問題を知ってそれでも使おうというのなら、更に改良を行う事が出来る。
	抑も version は、値の変更を検知する為に設置した物であるが、良く考えてみれば、変更される値は float pixel だけしか無いのだから、
	わざわざ version を使ってまで変更の検知を行う必要はないのである。
	則ち、親の version の代わりに親の pixel の値を直接持っていればいいだけの話である。故に、構造体は更に短くなって以下の様になる。
	大きさは <strong>16/24B</strong> である。
<pre class="cs">
class LengthChainElem{
	LengthChainElem parent;
	int p_pixel;
	
	float pixel;
}
</pre>
	<ul>
	<li>○ 値の変更時に何もしなくて良い。</li>
	<li>× レンダリング時に、親を全て辿って pixel を比較する必要がある。</li>
	</ul>
	<br />
</li>
</ol>
<p>上の一覧の中の「レンダリング時に、親を全て辿って云々」という件に関して、解決法がある事に気付いた。
親を全て巡って、とは言っても、<strong>レンダリングの最中に為される可能性のある変更までは対応しなくても良い</strong>はずである。
その為、一度辿って変更がない事が確認された親に関しては、再度辿る必要は無い。
一度辿ったかどうかを確認する際には、マークをつけると言う方法もあるかも知れないが、もっと良い方法がある。
</p>
<p>則ち、その要素をレンダリングしようとする時には、既に親が最新の値に更新されている事を前提にすればよいのである。
レンダリングの命令は概して、親要素から順番に伝播していく物である。その伝播の過程で、<strong>親が必ず値を更新すれば良い</strong>というだけである。
その様にしておけば、<strong>子は親の version/pixel を比較するだけ</strong>でよく、先祖にその問い合わせを伝播させていく必要はない。</p>
<p>亦、文書木の途中で変更が為された為に、その部分だけ改めてレンダリングしたいという場合もある。
その場合には、先ず、(1) その途中の部分から親に向かって辿っていき、ルートから更新を行う。
それが終わったら、(2) 通常の場合と同様に、その部分から子に向かって更新をしながら下っていく。という方法でよい。</p>


<!--##############################################################-->
<h1>afh.Rendering.Length - 2</h1>
<p>前回の afh.Rendering.FontSize の実装の経験 (試行錯誤で分かった事、失敗した事) を踏まえて、
亦初めから構成し直す事に決定した。今度の Length の設計をどの様にするかを茲に纏めてみる。</p>
<ul>
<li>単位 units (それぞれの単位が何 pixel に相当するか) は固定とする。
	則ち二つ以上の画面があって、それぞれの解像度が異なったとしても、
	どちらかの解像度を基準にして cm 等の物理的長さを画面上の px に変換する事とする。</li>
<li>印刷の際の調節に関しては、Drawer の方で行う事にする。
	(文字の大きさは FontManager が System.Drawing.Font と関連付けて保持しているので問題かも知れない。
	が、それは問題が生じてから考える事にする。何しろ、未だ印刷を行ってみた事がないのだから px がどう解釈されるのか分からないのであるから。)</li>
<li>LengthValue は長さの値を保持する構造体とする。(今後クラスに昇格させる可能性もあり。)
<pre class="cs">
struct LengthValue{
	float value;
	LengthUnit unit;
}
</pre>
</li>
<li>親子関係の実装/値の更新に関しては保留としておく。Style をちゃんと実装してから考える事にする。</li>
</ul>

<!--##############################################################-->
<h1>afh.Rendering.Style</h1>
<h2>ユーザー登録オブジェクト / 解釈後オブジェクト</h2>
<p>例えば、ユーザがプロパティに文字列の値を設定したとする。
内部的には、これを解釈してレンダリング時に利用しやすい形で記録するのが普通である。
然し、ユーザが自分の設定した値を再び参照しようとする事があるかも知れない。
その場合に、プロパティの型がユーザの予期していない物に変化してしまった時には問題が生ずる。
こう考えると、ユーザが設定したオブジェクト本体も何処かに記録して置き、ユーザが再びプロパティから値を取得しようとした場合には、
そちらのユーザが設定した方のオブジェクトを返す様にした方が良いのかも知れない。</p>
<ol style="list-style-type:lower-alpha;">
<li class="obsolete">別々の Dictionary に格納する様にする。
	<p>○毎回、解釈⇔文字列化 の操作を行わずに済む</p>
	<p>オブジェクトとして直接変更を行った際に、「ユーザーの登録した物」は変更するのかどうなのか?
	変更を実行する場合: オブジェクトに直接変更が行われた時に、その内容を纏めた文字列を「ユーザの登録した物」に代入しておく様にする。</p>
	<ul>
	<li>×ユーザの設定する型がどんな型なのかの予想が付かない。
		従って、内部的なオブジェクトをユーザの利用する型に変換する際には、その目標の型を何にするのかと言った事が問題になる。
		→実際にユーザが設定したオブジェクトの型を調べてそれに応じた変換を実行すれば良い。つまり、
		<ol>
		<li>ユーザが何も設定を行わない内には「既定の型」に変換する様にしておき、</li>
		<li>ユーザが一度でも設定を行った場合には、「何の型で設定を行ったのか」という情報を保持しておき、
			内部的なオブジェクトをユーザの取得する値に反映させる必要がある場合には、その記録された型に変換する</li>
		</ol>
		<p>と言う事である。然し、わざわざその様な事を実行する意味があるのかと言う事は疑問である。</p>
	</li>
	<li>※ユーザが設定を行う際には、設定しようとしているオブジェクトの型に併せて解釈を行えば問題はない。</li>
	</ul>
</li>
<li class="obsolete">毎回、適した形に変換するという操作を行う
	<p>例えば、ユーザが色を文字列で設定したとしても、格納される型は Color 型であり、ユーザが設定した元々の文字列の内容に関する情報は破棄する。</p>
	<p>△この場合、ユーザが "Red" と指定を行った場合でも取得されるオブジェクトは Color であり、
	それを文字列に変換すると例えば "#ff0000" の様になってしまう。</p>
	<p>→○この程度の事は仕方がない事である。寧ろ、この様な仕組みになっていた方が、返される値の型が安定しているので、
	ユーザも、「以前にどの型で設定を行ったのか」と言った事を覚えておかずに済むので良い。</p>
</li>
<li>[前項を少し改良] スタイルとしての情報と、レンダリングで使用する情報の両方を記録する。ユーザの設定した物は直接的には記録しない。
	<dl>
	<dt>レンダリングで使用する情報</dt>
	<dd>例えば色の場合には、レンダリング時にはその色が #ff0000 であるか、#f00 であるか、Red であるかは関係ない。
	全て、0x00ff0000 として扱えばいいだけの話である。亦、「長さ」の場合には pixel 単位での値が分かっていればよいのであって、
	それの単位が cm だろうが em だろうが % だろうが関係ない。</dd>
	<dt>スタイルとしての情報</dt>
	<dd>例えば色の場合には red と #f00 と rgb(255,0,0) 等はスタイルとしては区別するべきであろう。
	これらを区別する事が出来る様なスタイル記述情報を「スタイル情報」と呼ぶ事にする。
	例えば、長さの場合には値と共にその単位を記録する。</dd>
	<dt>ユーザの設定した情報</dt>
	<dd>ユーザの設定した直接的な情報は保持しない。例えば、"1cm" だとか、"1.0cm" だとかそう言った物は、
	ユーザの設定した情報としては異なる物であるが、茲ではその様な情報は保持しない。
	スタイル情報に変換された後の {値,単位} という値の組は保持されるが、
	これは元のインスタンスが "1cm" であるか "1 cm" であるか "1.000cm" であるかに関する情報は一切含まない。</dd>
	</dl>
	<ul>
	<li>ユーザが値を取得しようとする場合には、スタイル情報から復元する物とする。
	勿論、スタイル情報とユーザに提供する型が同一の場合には変換は要しない。</li>
	<li>レンダリング用情報は、スタイル情報とは別に保存する。その格納方法は色々案がある:
	<ol style="list-style-type:lower-roman;">
	<li>普通のプロパティとは異なる名前で保存する。例えば "\0color" など。
	(null 文字を使うとやはり後々で問題が生じてきそうなので、もっと他の表現方法を考える。)</li>
	<li>或いは、異なる Dictionary に記録するという手もある。
	異なる Dictionary の場合には、メモリは多少食う様になるかも知れないが、検索は早くなると考えられる。
	然し、スタイル情報＝レンダリング用情報の場合には、どちらか一方の Dictionary に情報を格納する形式になると思われる。
	之は、混乱の元であるので、やはり Dictionary は一つの方がよいのかも知れない。
	この辺りに関しては、実際に実装が完了してから調節 (Dictionary の増減) する事とする。</li>
	</ol>
	</li>
	<li>ユーザが値を設定する場合、先ずスタイル情報と種類が異なる場合には変換を行ってスタイル情報を得る。
	更に、スタイル情報とレンダリング用情報が異なる場合には同様に変換を行ってレンダリング用情報を得る。</li>
	</ul>
</li>
</ol>
<h3>各種情報の型</h3>
<p>ここでは、c. を採用する方向で考えたい。本当にこの方法で大丈夫かどうかを見当する為に、
各プロパティについて、ユーザの設定する型、スタイル情報、レンダリング用情報に関して整理を行っておく。</p>
<dl>
<dt>[lrtb]</dt>
<dd>left/right/top/bottom の略と言う事にする。
則ち、例えば margin-[lrtb] の場合には margin-left, margin-right, margin-top, margin-bottom の全てに対しての記述である事を示す。
</dd>
<dt>整数型</dt>
<dd>則ち、int, uint, long, ulong, short, ushort, sbyte, sbyte の事。※ char は含めない</dd>
<dt>浮動小数点型</dt>
<dd>則ち、float, double, decimal の事。</dd>
<dt>長さ</dt>
<dd>
	<p>適用先:</p>
	<ul>
	<li>font-size</li>
	<li>margin-[lrtb], padding-[lrtb], border-[lrtb]-width</li>
	</ul>
	<table class="normal table1">
	<colgroup><col span="2" style="white-space:nowrap;" /></colgroup>
	<tr><th /><th>型</th><th>説明</th></tr>
	<tr><th>レンダリング用情報</th><td>float</td>
		<td>pixel を単位とする大きさを表現する。之は、スタイル情報から計算される。
		相対長さの場合には参照する別の「長さ」を基準にして計算する必要がある。</td></tr>
	<tr><th>スタイル情報</th><td>{float,単位}</td>
		<td>値と単位の組合せで表現する。単位は列挙体で表現する。</td></tr>
	<tr><th>ユーザー取得</th><td>string</td>
		<td>文字列の形式は、数値を文字列で表現した物の後に単位を文字列で表現した物が続く形式になっている。例えば、"1.0cm" 等。</td></tr>
	<tr><th>ユーザー設定</th><td>string<br />{float,単位}<br />浮動小数点型<br />整数型</td>
		<td>文字列の形式は、「ユーザ取得」で述べたのと同様な形式になっている必要がある。例えば、"1.0cm", "1 cm", "1.00cm" 等。
		(数値と単位の間に空白を入れてもいいかどうかは検討中...)
		又、浮動小数点型、整数型で指定した場合には、数値は指定した値を float にキャストした物を使用し、
		単に関しては「既定の単位」を使用してスタイル情報に変換する事になる。</td></tr>
	</table>
</dd>
<dt>色  </dt>
<dd>
	<p>適用先:</p>
	<ul>
	<li>color, background-color</li>
	<li>border-[lrtb]-color</li>
	<li>scrollbar-base-color, scrollbar-highlight-color, scrollbar-3dlight-color, scrollbar-shadow-color, scrollbar-darkshadow-color, scrollbar-arrow-color, scrollbar-face-color</li>
	</ul>
	<table class="normal table1">
	<colgroup><col span="2" style="white-space:nowrap;" /></colgroup>
	<tr><th /><th>型</th><th>説明</th></tr>
	<tr><th>レンダリング用情報</th><td>ColorArgb32</td>
		<td></td></tr>
	<tr><th>スタイル情報</th><td>{bool, int}</td>
		<td>bool は之が、数値で指定したインスタンスか、それとも、色の名前で指定したインスタンスかを区別する為のフラグである。
		数値で指定したインスタンスの場合には int は、その 4B をそれぞれ ARGB に割り当てた物となる。
		色の名前で指定したインスタンスの場合には、int は列挙体の数値となる。</td></tr>
	<tr><th>ユーザー取得</th><td>string</td>
		<td>数値インスタンスの場合には #xxxxxx の形式で返す。色の名前で指定したインスタンスの場合には、その色の名前で返す。
		※ 中途半端な Alpha 値を持つ色に関しては #xxxxxxxx の形式で alpha 値も含めて返す様にした。</td></tr>
	<tr><th>ユーザー設定</th><td>"&lt;色の名前&gt;"<br />"#xxx"<br />"#xxxxxx"<br />"rgb(#,#,#)"<br />int, uint</td>
		<td>色の名前は予め登録してある物を設定する。大文字小文字は区別しない。従って、ToLower を掛けてから検索する仕組みにする。
		#pqrstu の形式の場合、色は 0xffpqrstu となる。また、#pqr の形式は #ppqqrr と同じである。
		rgb(r,g,b) の場合には、それぞれ r, g, b を赤緑青の強度 (0-255) とする色の表現である。
		32bit 整数で設定した場合には、それをぞれぞれの B に ARGB を当て嵌めて解釈する物とする。</td></tr>
	</table>
</dd>
<!--
<dd>
	<table class="normal table1">
	<colgroup><col span="2" style="white-space:nowrap;" /></colgroup>
	<tr><th /><th>型</th><th>説明</th></tr>
	<tr><th>レンダリング用情報</th><td></td>
		<td></td></tr>
	<tr><th>スタイル情報</th><td></td>
		<td></td></tr>
	<tr><th>ユーザー取得</th><td></td>
		<td></td></tr>
	<tr><th>ユーザー設定</th><td></td>
		<td></td></tr>
	</table>
</dd>
-->
</dl>
<!--==============================================================-->
<h3>System.Windows.Color 色の実装</h3>
<p>文字列からの読み取りの際に、rgb(#,#,#) の形式を読み取る事になっている。
現在の実装では # の部分には非負整数しか指定する事が出来ない。
<span class="totei">将来的には十六進表記、八進表記、浮動小数点表記に対応し、更に簡単な数式の読み取りも実装したい。</span>
</p>
<p>現在の文字列読み取りの方法:</p>
<ol>
<li># で始まる場合には、以降に十六進数が存在するとして読み取る。
三桁の場合には rgb と解釈し、四桁の場合には argb と解釈する。
六桁の場合には RrGgBb と解釈し、八桁の場合には AaRrGgBb と解釈する。</li>
<li>単語の場合には、全て小文字に直して、登録されている色の名前と照合する。</li>
<li>単語の後に ( が直ぐ続く場合には、"色関数" として読み取る。
rgb(#,#,#) と言った感じに指定すると、一つ目を R の強度、二つ目を G の強度、三つ目を B の強度として読み取る。</li>
</ol>
<h4>予定</h4>
<ul>
<li>色名を自分で登録できるようにする。日本語色名にも対応する。</li>
<li>日本語に対応する場合 (option で指定) には、tolower と共に、半角片仮名・片仮名/旧字・簡体字変換も用意する。</li>
<li>色関数を自分で登録できるようにする。</li>
<li>色関数の引数には簡単な数式も指定できるようにする</li>
</ul>

<p>その他の実装に関しては、今のところ問題はない。</p>
<!--==============================================================-->
<h2>属性値の継承</h2>
<p>古い実装の考察では以下の様になっている (古い実装は中止になって、亦初めから作り直す事になった)。
新しい実装でも、以下の様になると思われるが、実装をもっと慎重に行う為に考察を深める。</p>
<div class="note obsolete">
	<p>[継承されるプロパティと継承されないプロパティ]</p>
	<p>継承される物と継承されない物を区別して、
	それぞれに対して、値の取得を行う方法を変えなければならない。
	継承される種類のプロパティは親を探索する仕組みにする。
	継承されない種類のプロパティは既定値を返す様にする。</p>
	<p>親が存在していない場合には、継承されない種類のプロパティと同じく既定値を返す様にすればよい。</p>
</div>
<p>属性には、継承される様な種類の物と、継承されない種類の物が考えられる。
継承される様な物の例としては、font-size 等がある。
逆に、継承されない種類の物は border-width 等である。</p>

<p>所で、その前に茲で使う用語について整理しておく事にする:</p>
<div class="note">
<dl>
<dt>要素</dt>
<dd>スタイルを保持する描画単位の事である。</dd>
<dt>親要素</dt>
<dd>要素の親の描画単位の事である。
スタイルから見ると、それを保持している描画単位の更に親の描画単位という事になる。
また、要素と親要素は相互に参照を保持しているという事にする。</dd>
<dt>親スタイル</dt>
<dd>親要素の保持するスタイルインスタンスの事である。</dd>
</dl>
</div>

<p>スタイルは描画単位毎に保持するので、親の描画単位のスタイルを継承する様な属性値を実現する為には、
親のスタイルを参照する為のそれなりの方法を考えなければならない。
茲で問題になるのは、その参照をどの様に取得するかという事である。</p>
<ol style="list-style-type:lower-alpha;">
<li>要素への参照を保持
<p>この場合には、要素自体が親要素の参照を持ち、その親要素が親スタイルへの参照を保持しているので、そこから参照を得る事が可能である。
然し、この様になっていると何段も参照を辿らなければならないので、頻繁に参照する場合には向かない。
(とは言っても、この程度の事でどれだけのオーバーヘッドがあるのかというのは疑問である。)</p>
</li>
<li>親スタイル自体への参照を保持
<p>○ こうすると、上の方法の様に何段も参照を辿る必要はなくなる。</p>
<p>この場合には、要素・親要素の関係を変更する際などに、この参照自体も書き換えるように注意しなければならない。</p>
<p>△ と言う訳で、これは頻繁にドキュメント構造が変わる場合には向かないと言えるが、
実際にはその様な状況は想定していないのでこの問題点に関しては無視して良い事とする。</p>
<p>× 亦、コードが見にくくなると言う可能性もある。実際には、初めは上に述べた方法で実装して、
或る程度落ち着いてからこの方法に変更するという事も考え得る。</p>
<p class="obsolete">(然し、やはり、見にくくなると言う根拠はないので、この問題点に関しては考えない事にする。
見にくくなると思ったのは、今迄の実装で「親スタイル自体への参照を保持する仕組みにする」か、
「要素への参照を保持する仕組みにする」かの間で機構を度々変更しようとした際の経験からであろう。
これは、この仕組み自体が良くなかったのではなく、定まらない実装計画が悪かった為である。
以降は、どの方法で実装するかを明確にして実装を行うのでこの問題は生じないと予想される。)</p>
</li>
</ol>
<p>所で、スタイルが要素の参照を保持している必要性はあるのだろうか?
親要素のレンダリングに関する情報は全てスタイルが保持している訳であり、
スタイルの方から要素の情報を必要とするという状況は現在の所ではない様に思われる。
その為、上で述べた中では b. (二番目) の「親スタイルへの参照」を保持して、他の物は保持しないという方法の方がよいのではないか? とも考えられる。
かかる理由によって、取り敢えずは b. (二番目) の方向で実装してみる。問題点が生じてきたら再度検討する。
</p>
<p class="obsolete">逆に言えば、要素は何の情報を持っているのかという疑問にも繋がる。
要素が保持する様な情報はすべてスタイルの一プロパティに還元する事が可能なのである。
寧ろ、要素が何も情報を持たないのであれば、スタイル自体を要素として扱っても良いのではないか?
否、然し、スタイルをオブジェクトとして独立させた元の理由は、様々な種類の要素の間で共通するプロパティを纏めるという物であった。
茲で、スタイル自体を要素として扱うのであれば、実際の様々な種類の要素に対応して、
色々な種類のスタイルを考えなければ為らずそれらを管理するのは面倒である。</p>
<!--==============================================================-->
<h2>Cascade</h2>
<p>ブラウザとしても通用する様なスタイルを実装する上で重要なのが cascading である。
これを実装する方法の案をここに与える。</p>
<ul style="list-style-type:lower-alpha;">
<li>要素が複数の Style を保持しその中で最も優先度の高い物を使用する。
 <p>×この方法だと、要素自体の実装の中に、スタイル選別のロジックを書かなければならない。スタイルに関する処理は全てスタイルに任せるべきである。</p>
</li>
<li>Style 自体が複数の cascading sibling (と茲では称する事とする) を保持する。
 <p>この場合、selector の適用などの判定は要素の情報も利用しなければならない為、cascading sibling の内容は style を保持する要素の側で行う物とする。</p>
</li>
</ul>
<p>※ Cascase を利用するのは実際に Rendering に使用するプロパティだけである。
他のプロパティに関しては、特にユーザの要求がある場合以外には Cascade を行う必要はない。
特別にユーザの要求がある場合に関しては別に実装すればよい。</p>
<h3>既定値の実装</h3>
<p>既定値の実装に関しては、以前は以下の様に考えた。</p>
<div class="note obsolete">
	<p>[既定値の管理]</p>
	<p>全てのプロパティの値を使っていないのに登録していたらメモリを食うし、初期化に時間が掛かる。
	その為、既定値を定義しておいて、使っていない場合には既定値を使用するようにする。</p>
	<p>GetColor 等の特化関数の場合の既定値の管理の方法:</p>
	<p>static field に既定値を保持しておく。GetColor(キー,既定値) 等の方法を採る。</p>
	<ul>
	<li>×既定値を使用しないのに既定値を毎回受け渡ししなければならないのは非効率的である。</li>
	<li>→既定値の受け渡しのオーバーヘッドを考えるのであれば、
	初めから、既定値の表を持って置いて、必要になったらそれを参照するという仕組みにした方が効率的であろう。</li>
	<li>→然し、それでも非効率的なように思われる。実際の所最も効率的なのは、
	値を取得する為のプロパティのロジック中に既定値を即値 (或いは何処かの field) として書き込む事である。
	<p>こうすると、色専用/整数値専用のコンテナに移行する際に問題が生ずるように思われるが、
	実際には面倒になると言うだけで、特に問題は発生しないと考えられる。何故なら、そのコンテナへの
	アクセスを行う関数は Style class の中だけにしか存在せず、型毎に関数を纏めておけば、移行し忘れも防げよう。
	</p>
	</li>
	</ul>
</div>
<p>然し、cascade を利用する事を考えた今は、既定値も cascade を以て実現する事とする。
この様にした方が自然であるし、ロジックもすっきりする。
以前に考えた既定値の方法と比べて performance の問題もあるのかも知れないが、
この overhead は cascade を実装する上では避けられない事であるので、
特に既定値を cascade を以て実現する事によって遅くなるという事はない。</p>
<p>具体的には default stylesheet として、cascade sibling のリストの一番最初に登録しておく</p>
<!--
・登録されているプロパティと登録されていないプロパティ
　登録されているプロパティは、大文字小文字を区別しない。
　　→既に HTML 等で採用されている物だけでよい。
　　それ以外の独自に定義する物は大文字小文字を区別する様にする。
　登録していないプロパティは、大文字小文字を区別する。

・型変換のオーバーヘッドを下げる為に、型別にコンテナを用意するか?
　○型変換のオーバーヘッドを下げる事が出来る。
　　特に、Color や int の物は描画の際に頻繁に使用すると考えられる。
　　→特に描画の際によく使う物に関しては、直接 field を保持するという手もある。
　×this[string] によるアクセスの際に、文字列によってコンテナを切り替えなければならないという問題がある。
　×型の種類だけ作っていたら、メモリを沢山食う事に為る。 4B × 4 × (型の数)
　　→沢山のプロパティを持っている型だけで良い。Color や int 等。
　結論: 今は取り敢えず、一つのコンテナに格納して実装する事にする。
　　　　完成してから、遅いようならばコンテナを別の物にすり替えるなどの処置を行う。
　　　　その為には、型別に GetColor 等の関数を用意しておくと切替が容易になる。

-->
<!--##############################################################-->
</body>
</html>