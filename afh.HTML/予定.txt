■HTML Parser

<script> の中身を </script が登場するまで読み飛ばす。
<style> の中身を </style が登場するまで読み飛ばす。

何故か <meta/> 等の自己終端要素の判定が入っていない。自己終端要素の一覧は組み込まれてはいるが...

■afh.Tester
[分かった事] を編集する TextBox を追加
　[分かった事] の内容を保存する (関数名に従って)

benchMark ボタンを追加する
　一回実行するのにどれだけ掛かるのかを計測
　invoke は重いので、Reflection.Emit でループを記述する。
　空呼び出しの時間を計測して引き算する。

例外の TargetInvokationException は表示しない様にする
　Ref::TargetInvokationException の InnerException を表示する

■afh.HTML

□DOM を真面目に実装する

・index を各 HTMLNode が保持する様に変更する。
  現在の実装では、毎回親に問い合わせて自身を検索するようになっている。
  然し、この方法だと一つの要素に大量 N の要素が存在する時に、
  nextSibling で伝っていく時に N^2 のオーダーの時間が掛かってしまう。

  1.現在 HTMLNode は IHTMLNode を実装するようになっているが、これを HTMLNode だけにする。
    index プロパティは内部だけからしか変更できないようにしたいが、
    インターフェイスにしていると全体に公開しなければならないからである。
    
    [必要性があるか分からないが]
    外部から定義したノードを含めたいという要望に対しては、
    IHTMLNodeDetail を実装して貰う事にして、
    それを参照して HTMLNode として振る舞うクラスを作成すればよい。
  
  2.childNodes の実装
    childNodes に対して挿入や追加や削除などがあった場合に、
    index を一斉に更新しなければならない。
    その為、childNodes は特別に HTMLNodeList クラスとして実装する必要がある。
    
    [問題点] [無視]
    既に N 個の要素がある時に先頭に N 個の要素を一個ずつ追加しようとする場合、
    index を N^2 のオーダーだけ書き換える作業が生じる。
    然し、良く考えたら、要素の移動だけでも N^2 のオーダーかかってしまうので、
    index の書き換えに N^2 でも余り問題はない。
    寧ろ、一個ずつ挿入するようなコードを書くのが悪い。
    

□互換性変更点

・IHTMLNode -> HTMLNode
    IHTMLNode を廃止し、全て HTMLNode から継承するように強制

■afh.Rendering

表示の更新の仕組みをどうするか
　サイズの変更などがあった場合に、それを上へと伝えていく
　　×サイズ等のパラメータを変更するだけで可成り重くなる可能性がある
　　　上へ伝達するのにデリゲートを沢山使ったり、イベントを使用したりすると考えられる為…
　一秒間に何度も更新を行い、変更を伝達する仕組みを整えずに済む様にする
　　×これは、静的な物を表示したい場合などにはとても非効率

その位置に表示されている物を取得する仕組み
　※マウスによるイベント等を伝達するのに必要
　※テキストを囲むのにも必要 (テキストを囲む場合には、項目の順番や、TextNode 内での文字列の位置の管理なども重要になってくる)
　・その為には、先ずイベントの仕組みなども整えておかなければならない
　・Internet Explorer の実装を参考にすると良い。
　
□スタイルの実装
・継承されるプロパティと継承されないプロパティ
　継承される物と継承されない物を区別して、
　それぞれに対して、値の取得を行う方法を変えなければならない。
　　親を探索するか、既定値を返す様にするか。
　　親が存在しない場合にも、継承しないプロパティと同じ扱いにする。

・登録されているプロパティと登録されていないプロパティ
　登録されているプロパティは、大文字小文字を区別しない。
　　→既に HTML 等で採用されている物だけでよい。
　　それ以外の独自に定義する物は大文字小文字を区別する様にする。
　登録していないプロパティは、大文字小文字を区別する。

・型変換のオーバーヘッドを下げる為に、型別にコンテナを用意するか?
　○型変換のオーバーヘッドを下げる事が出来る。
　　特に、Color や int の物は描画の際に頻繁に使用すると考えられる。
　　→特に描画の際によく使う物に関しては、直接 field を保持するという手もある。
　×this[string] によるアクセスの際に、文字列によってコンテナを切り替えなければならないという問題がある。
　×型の種類だけ作っていたら、メモリを沢山食う事に為る。 4B × 4 × (型の数)
　　→沢山のプロパティを持っている型だけで良い。Color や int 等。
　結論: 今は取り敢えず、一つのコンテナに格納して実装する事にする。
　　　　完成してから、遅いようならばコンテナを別の物にすり替えるなどの処置を行う。
　　　　その為には、型別に GetColor 等の関数を用意しておくと切替が容易になる。

・既定値の管理
　全てのプロパティの値を使っていないのに登録していたらメモリを食うし、初期化に時間が掛かる。
　その為、既定値を定義しておいて、使っていない場合には既定値を使用するようにする。
　
　GetColor 等の特化関数の場合の既定値の管理の方法
　・static field に既定値を保持しておく。GetColor(キー,既定値) 等の方法を採る。
　　×既定値を使用しないのに既定値を毎回受け渡ししなければならないのは非効率的である。
　→既定値の受け渡しのオーバーヘッドを考えるのであれば、
　　初めから、既定値の表を持って置いて、必要になったらそれを参照するという仕組みにした方が効率的であろう。
　→然し、それでも非効率的なように思われる。実際の所最も効率的なのは、
　　値を取得する為のプロパティの中に既定値を即値 (或いは何処かの field) として書き込む事である。
　　　こうすると、色専用/整数値専用のコンテナに移行する際に問題が生ずるように思われるが、
　　実際には面倒になると言うだけで、特に問題は発生しないと考えられる。何故なら、そのコンテナへの
　　アクセスを行う関数は Style class の中だけにしか存在せず、型毎に関数を纏めておけば、移行し忘れも防げよう。
　　　　
□イベントの実装
茲で言っているのは、再描画の要求など、内部的に使用するイベントではない。
ユーザに公開するイベントである。スクリプトからも利用出来るように考える必要がある。
イベントのシグニチャは object(EventArgs) に統一するべきである。(イベント発信者 sender も EventArgs に含めてしまう)
　イベントによってはより詳細な情報が必要とされる事もある。
　例えば、マウスの位置などの情報。
　この場合には EventArgs を拡張した物をシグニチャに取る事も出来る。
　然し、イベントの種類によって EventArgs の型がどうなるかと言った事を気にするのは面倒である。
　A.そこで、関数は全て EventArgs を受け取るように統一する。
　　×その場合には、関数の内部で適した EventArgs 継承型にキャストしなければならないという面倒が待っている。
　　×イベントの情報を必要としない場合に到っては引数を取らない種類の関数も設定したく為るであろう。
　B.関数のシグニチャは自由で、受け取った関数のシグニチャに応じて、キャストなどを実行する。
　　→毎回実行時に、Reflection で関数のシグニチャを判定して…というのは時間が掛かるので、
　　　イベントへの設定時に Reflection で関数のシグニチャを判定し、必要に応じて Reflection.Emit で、
　　　ラップ関数 object(***EventArgs) を生成する事にすると良い。
　　○ラップ関数によって対応出来ないと判定される場合には、その時点 (=設定の時点) でエラーを発する事が可能である。
　B. の方が魅力的である。B に決定する事にする。