■Regex
・非決定性をどうするか ?

a. あらゆる可能性を同時に計算
	理論上は可能であるが
	× 設計が面倒であるし、
	× 計算速度も使用資源も最悪
	
b. 一回ずつ別の方法を試して行って最初に通ったのを選択
	これは、a. の場合よりは設計は簡単になる。
	
	ただ、毎回最初からやり直すのは速度が遅くなるので、非決定性分岐点から計算を再開する様にしたい。
	すると、急に設計が面倒になる。
	・非決定性分岐点に於けるスタックの状態を簡単に復元することが出来ればよいのかもしれないが、それは出来ない。
	・関数呼び出しの入れ子に頼らない様な方法を考えれば状態を復元することは可能かもしれない。
	　→面倒、難しい
	　
	・非決定性分岐点以降の処理は、非決定性分岐点を処理した関数から戻らずに行う
	　×非決定性分岐点が、括弧の中に在った場合の処理などが困難
	　　正規表現の構造に沿った検定の方が設計し易い。
	　×非決定性分岐点が幾つも現れ出たときに、容易に stack-overflow し得る。

c. 結局 b. の方法を改良して使う事にする
　スタックの状態を復元するというのは CLR でしか出来ないので、
　__minor(continuous) で関数の入れ子呼び出しを無くして、
　Indefinite な場合には状態を clone して取っておく事にした。

　×もう match する物がないのに Indefinite を返す場合がある。
　例: (abc|bc)
　　abc で match したとする。
　　もうこの時点で bc には match しないという事が分かっている。
　このような場合には、一つ目の match を見つけた時点で、
　他に match する物がないかどうか確認してから次に進むという操作で対処できる。
　但し、その為には
　1. 二つ目を先読みした後に、状態を一つ目の match 直前に戻したり
　2. 二つ目の match の状態を覚えておいて、いざ二つ目の match が要求されたときにそれを思い出したり
　などの操作が必要になる。

□予定
文字列からの読み取り(Parse)…デバグをしやすくする為
→大体完成した。
　但し、文字クラス [] の読み取りには未だ対応していない。
→文字クラスの読み取りにも一応対応した。然し、可成り効率が悪い。
　1. delegate で実装しているが、interface で実装し直した方が良い。
　　 更には Reflection.Emit も比較的容易ではないかと考えられる。
　2. [abcdefghijk] を 'a' にマッチさせる場合に、本来ならば一番初めのマッチで決定の筈だが、
　　 後ろに文字クラス減算が来る可能性の為に、全てに対して評価を行う事になっている。
　　 これを改善出来る筈である。

>LazyRepeat
>Capture
ループを作る事が出来るようにする
	INodeNode
	無限 loop のロジックになる可能性に注意 (構成する人に任せるか?)

ITester::NodeAssociativity は不要であると言う事

RegexFactory<T>.Status は現在の所、内部に T 配列を保持しているが、
それに類する別の T 型系列に対しても適用できるようにする。
→ITypedStream<T> として実装。置き換えも完了

RepeatNode の空一致による無限ループ
連続する ElemEqualsNode の縮約
グループ化構成体の中身が null だった時の動作 (εノードを導入するか?)
