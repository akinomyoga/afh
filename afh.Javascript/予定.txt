このライブラリで扱う物
1. Javascript の Object Model の表現
2. 実行の方法を提供 (Function:Object)
2. Javascript の Parse

=====================================================================
		1. Object Model
=====================================================================

本来の Javascript との相違点
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 値型と参照型の区別は行わない→全て参照型

  例: 数値リテラルも Number() も new Number() と同じく Object として扱う。

* 全てのオブジェクトは Object より派生する

  例: Javascript の外から作った COM 等のオブジェクトも全て Object で wrap する
  例: グローバル変数や関数内変数も特別な Object のメンバとして扱う

* property のサポート(これは、上の項目から必然的に必要になってくる)

  ※: 通常の代入では property を定義する事は出来ない
      (プロパティに値を代入したいのか、プロパティ自体を別の種類のメンバで置き換えたいのか曖昧になる為)
      → delete *** してから代入すれば良い。

* 演算子の再定義

  ※: 演算子もメンバとして扱う

メンバの管理
~~~~~~~~~~~~

通常のメンバと隠すメンバ
^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
* Hashtable で管理する事にする
  Hashtable は二つ定義する
  1.一つは通常のメンバを保持する
  2.もう一つは特別なメンバを保持する(例えば、__proto__)
    何故この様な特別メンバを区別するかというと、
    既存のインタプリタはそういった物を区別するからである。
    更に、独自に二つを区別しない様にすると問題が生ずる。
    メンバの中には、コピーしても意味がなかったりエラーの元になったりする物が含まれるのである。
		例えば、[native code] を呼び出す様な関数(その Object に密接に関わる為他の Object にコピーしても実行出来ない)や
		__proto__ (その Object の継承を表現する) である。
    既存のプログラムの中には「全て」のメンバをコピーする物があり、
    これは既存のインタプリタの実行に依ると通常のメンバしかコピーされない様になっている。
		(これは、prototype ベースの Javascript の特徴を象徴する様な使用法である)
* __proto__ だけは殆どのオブジェクトに必要になると思われるので別の管理方法を選択[0.1]
* hashtable を二つ用意せずに、その関数の種類(Function, ManagedMethod など)を使って「区別」する方法は?
  Function は他の Object にコピーする意味がある。→ key 列挙の際に渡す
  ManagedMethod は他の Object にコピーしても意味がない→ key 列挙の際に渡さない
  →取り敢えず、Object の実装を二種類用意して置いて後で決める事にする
  
他
^ ^

* アクセスは文字列を通して行う(配列も同様)
* 先ず初めに .NET の関数を呼び出す仕組みを実装しないと話にならない?

実装に於ける型の対応
~~~~~~~~~~~~~~~~~~~~
* .NET:	null	⇔	Javascript:	undefined
* .NET:	Null	⇔	Javascript:	null

=====================================================================
		2. 実行の方法
=====================================================================

■ソースの解析
　ソースを実行する前に先ずやらなければならない事はソースの解析である。
　つまり実行する前に、ソースを構文解析して、扱いやすいデータ構造にプログラムを格納する必要がある。
　このデータ構造を決めない事には何も出来ない。と言う訳で、ここでそのデータ構造に関して考えてみる事にする。
　
1. 通常の手続き的呼び出し
~~~~~~~~~~~~~~~~~~~~~~~~~
例
	var num1=new Number(0.555);
	var num2=new Number(103.6767);
	var num3=num1+num2;
	return num3.toString();
	-----------------------------------
	push	0.555				// 0.555
	invoke	[Number] 1			// Number(0.555)
	store	[num1]				// Number(0.555)
	pop							//
	push	103.6767			// 103.6767
	invoke	[Number]			// Number(103.6767)
	store	[num2]				// Number(103.6767)
	pop							//
	load	[num2]				// Number(103.6767)
	invoke	[num1,:+:] 1		// Number(104.2317)
	store	[num3]				// Number(104.2317)
	pop							//
	invoke	[num3,toString] 0	// String("104.2317")
	ret
	
	参考の為に、どの様に解析したらよいかについて括弧で括って見た。(↓)
	この様にして括弧と矢印で記述する事が出来れば、上の様なアセンブリ擬きにする事は容易である。
	-----------------------------------
	[var num1=]←(new Number)←0.555
	[var num2=]←(new Number)←103.6767
	[var num3=]←(num1+)←num2
	[return]←(num3.toString)←
	-----------------------------------
	具体的な解析方法に関しては、もっと他の命令も見た後に総合的に考えたいので後にする。

例
	return new Array(0.122, 3.1231, 100);
	--------------------------------
	push	0.122
	push	3.1231
	push	100
	invoke	[Array] 3
	ret
	---------------------------------
	[return]←(new Array)←{0.122, 3.1231, 100}

2. 条件分岐などのコード
~~~~~~~~~~~~~~~~~~~~~~~
* 例
	if(x){
		[SomeCodeA]
	}else{
		[SomeCodeB]
	}
	-----------------------------------
	/*	code1	*/
	load	[x]
	brfalse	00
	[SomeCodeA]
	br		01
00	[SomeCodeB]
01　nop

	【亦は】
	
	/*	code2	*/
	load	[x]
	push	[SomeCodeA]		// 命令文自体をオブジェクトとして扱いそれを渡す
	push	[SomeCodeB]		// or 命令文への参照を保持する整数などを渡す
	invoke	[:if:] 3
	
*	二番目の方法だととても効率が悪い様に思われるかも知れない。
	然し、若し下の様になっていたらどうであろうか?
	
	/*	code3	*/
	load	[x]
	push	00-01			// 範囲を示す値
	push	01-				// 範囲を示す値
	invoke	[:if:] 3
	ret
00	[SomeCodeA]
01	[SomeCodeB]

	これは同じ配列の上にプログラムを確保した場合である。こうして見ると
	code1 の場合と異なるのは現在の実行位置を、仮想機械で直接行うか
	:if: 関数の中で行うかという点のみである。もっと分かりやすく言えば、
	code1 は仮想機械に新しく分岐・ジャンプなどの機能を付けるという事であり、
	code2 は仮想機械が既に持っている関数呼び出しの機能を簡単にして流用しようと言う物である。
	
*	更に、プログラムが同じ配列上にある必要はないので、
	
	/*	code4	*/
:現在の関数:
	load	[x]
	push	:SomeCodeA:		// 範囲を示す値
	push	:SomeCodeB:		// 範囲を示す値
	invoke	[:if:] 3
	ret

:SomeCodeA:
	[SomeCodeA]
	ret

:SomeCodeB:
	[SomeCodeB]
	ret
	
	と言った具合になっていても構わない。
	勿論、この場合には :if: 関数は別の所で定義されている
	(何れにしても条件判断を伴うので別の言語で記述する必要がある)
	
*	ところで、この :SomeCodeA: 等の呼び出しの際に普通の関数の呼び出しと異なる点と言えば、
	ローカル変数を完全に共有するという点である。更に、引数も持たない。
	つまり、__context__ をその儘にして実行するという呼び出しの仕方である。
	
3. ループなどその他
~~~~~~~~~~~~~~~~~~~
*	2. と同様にして
	
	while([...])[...]
	
	do[...]while([...]);
	
	for([...];[...];[...])[...]
		//※ for の中の初めの [...] は for 呼び出しの前に実行して構わない。
	
	switch(val){
		case val2:[...]
		case val3:[...]
		default:
	}
	
	switch 文の構成を考える前にラベルについて考えないと行けない。
	
*	さて、この様にして一般化しやすい形で分岐などの方法を考えた為、
	勝手に新しい構文を定義するのも簡単になった (かも知れない)。
	また、この 2. の方法による呼び出しは通常の関数呼び出しとは異なる為
	invoke ではなく enter を使用する事にする。(※ クロージャなどの場合には
	クロージャ自体関数の様な性質を持つので invoke で呼び出す機構に組み込む事にする。)	

4. ラベル
~~~~~~~~~
	ラベルと言っても単純に、<ラベル名,位置> を保持するテーブルを用意すれば良いだけなのかも知れない。
	これに関しては、もっと後になってから考える事にする。

5. 制御を抜ける操作
~~~~~~~~~~~~~~~~~~~
*	制御を抜ける操作の例として、 break や return 等がある。
	これの場合は、どんどん呼び出し元に伝搬していって何処かで止める事にすれば良い。
	
	break の場合はどんどん抜けていって while や for や switch で捕まえる事にする。
	continue の場合は while や for の所で捕まえて、もう一回実行をすればよい。
		上の二つにはラベルが付いている可能性があるので、
		それも一緒に伝搬しながら while や for 等のラベルに合致すれば捕まえるという事にすれば良いが、
		その為には while や for が (若し割り当てられているのなら)
		自分にどのラベルが割り当てられているのか知っている必要がある。
	return の場合は関数の所で捕まえて値を返すなり何なりすれば良い。
		この場合は、返値が指定されている可能性があるのでそれも一緒に伝搬しなければならない。
	throw の場合には関数の呼び出しまでも遡る必要がある。(当然 try で捕まえればよい)
		・この場合には、エラー情報を一緒に伝搬する。
		　エラー情報には現在の呼び出しのスタックの状態も含む。
		　この呼び出しのスタックの情報は則ち、遡る時に使用した物と同じ筈であるからそれ程難しくはない。
		・最後まで掴まらずに終わる事があるが、この場合にはエラーとしてプログラムが停止する。
		　これは while や for の中にいる訳でもないのに continue を使った場合なども同様である。
	
*	序でに goto に関しても註釈を加えておく事にする
	goto は現在のスコープでラベルを探してそこにジャンプするという物であるが、
	若し見つからなかった場合には一つ上の階層を探すという事にする。
	つまり、見つかるまで呼び出し元を遡上する訳である。
	勿論、関数やクロージャ自体を抜けるという事はしない。
	
*	実際に抜ける方法に関してどの様な方法を採るのかは未だ分からない。
	　例えば C# の例外を使用する方法がある。所が、この方法だとオーバーヘッドが大きくなる可能性がある。
	これは、極力 throw の場合にのみ使用する事にしたい。
	　一方で、コード片の実行に際してはコード片がどの様にして終わったのかを返す機構を用意したい
	例えば Natural Return Break Continue Throw 等を区別する列挙体とそれに伴うデータの組合せなどである。


=====================================================================
		C# 動作メモ
=====================================================================

キャスト
~~~~~~~~
* is 演算子:
  null is Type			=> false
  Type t=null;t is Type	=> false (コンパイラは「常に true」と警告を出すが)
  null is typeof(Type)	=> × syntax error
  ※ 或るオブジェクトが System.Type this.type に変換出来るか否か
   → t==this.type||t.IsSubclassOf(this.type)||t.GetInterface(this.type.FullName)!=null で判定可能
      (但し FullName に "+" が含まれる様な場合は駄目かも知れない)
  
* as 演算子:
  null as Type	=> null
  
* キャスト演算子:
  (Type)null	=> NullReferenceException

GetMethods で取得出来る物
~~~~~~~~~~~~~~~~~~~~~~~~~
* メソッド
* プロパティの getter 及び setter

※ 静的メンバも取得する
※ 継承元のメンバも取得する
※ コンストラクタは取得されない
※ override された物は取得されない

※ bindingFlags を使用する際
 * 少なくとも Static/Instance と Public/NonPublic を指定しないと何も取得出来ない 

Exception にかかる時間
~~~~~~~~~~~~~~~~~~~~~~
* 一回目の NullReferenceException は時間がかかる (resources を読み込んでいる?)
  → .NET Framework 2.0 では時間が掛かる様な事は無い様である。
* 通常の throw では catch すれば時間はかからない
  catch しないと時間がかかるかも知れない。(エラーを通知するダイアログが表示される迄に)


ParamsAttribute
~~~~~~~~~~~~~~~
* その ParameterInfo が params を指定されているか否かの判定
  parameterInfo.GetCustomAttributes(typeof(System.ParamArrayAttribute),false).Length>0
* 例:void func(params int[] ints);
	func(1,2,3)			=> OK
	func()				=> OK	//ints は要素数 0 の配列になる
	func({1,2,3})		=> OK	//※ {1,2,3} は new int[]{1,2,3} を表す
	func({1,2,3},1)		=> ×
	func({1,2,3},{1,2})	=> ×
	
静的メソッドとインスタンスメソッドのシグニチャ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 静的メソッドとインスタンスメソッドで名前とシグニチャが同じ物があるとコンパイルエラーになる

BeginInvoke EndInvoke
~~~~~~~~~~~~~~~~~~~~~
* BeginInvoke される関数内で、自スレッドの名前を変更するコードを書くと二回目以降の呼び出しでエラーになる
  →実は同じ関数の呼び出しには同じ Thread オブジェクトが使い回されるらしい
  ・呼び出し元の delegate インスタンスが異なっても同じ関数なら使い回しされる

lock
~~~~
* 別に lock すると他のオブジェクトからアクセスできなくなるという訳ではない…
  lock を使用した statement の中で使用できなくなると言うだけ…


配列の要素の型
~~~~~~~~~~~~~~
　配列の要素の型を取得する際には array.GetType().GetElementType() を使用すればよい。
　更に System.Type t を要素に持つ様な配列のインスタンスを作成したい場合には、
　	System.Collections.ArrayList list に要素を add して置いて ToArray(t) とすれば良い。
=====================================================================
		無関係: C# あると便利そうな仕様
=====================================================================
* 関数のシグニチャに列挙子を入れると、その列挙子を指定した時にその関数が呼び出される
* switch 内の continue で次の case ラベルに流れる
* リテラルの定義
  例: "..."reg
	//文字列リテラルの後ろに演算子を挟まず文字や文字列が付く
	//二重に定義されてしまったりすると大変なので、各ファイルの先頭で
	//	#using stringliteral reg MyNamespace.RegularExpression:id
	//等と定義する…これを使用する条件は
	//	interface IParseStringLiteral{
	//		object ParseLiteral(string id,string str);
	//	}
	//を実装している事
  例: [数値]Cc, [数値]i[数値], [数値]a[数値]b[数値]c
	//数値の後ろに文字列が付いたり、文字列を挟んで数値があったりする
	//各ファイルの先頭で
	//	#using numliteral Cc=MyNamespace.Temperature:id
	//	#using numliteral Fh=MyNamespace.Temperature:id
	//	#using numliteral Kv=MyNamespace.Temperature:id
	//	#using numliteral i=MyNamespace.ComplexNumber
	//	#using numliteral a b c=MyNamespace.Abc:id
	//等と定義する…これを使用する条件は
	//-------------------------------------------
	//案 1. →没
	//	interface IParseNumericalLiteral{
	//		object ParseLiteral(string id, object[] nums);
	//
	//		//i 番目の数値の型が何で在るべきかを指定(System.Type は数値型でないと行けない)
	//		System.Type[] GetLiteralTypes(string id);
	//	}
	//を実装している事
	//-------------------------------------------
	//案 2.
	//	Parse を行う関数にカスタム Attribute を付ける
	//	[ParseLiteral(id="Celcius")]
	//	Temperature getCelcius(double t);
	//
	//	[ParseLiteral()]//id を指定しない場合も可
	//	ComplexNumber GetComplex(double re, double im);
	//
