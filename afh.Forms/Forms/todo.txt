
■TreeView 実装


計画1. スクロール
~~~~~~~~~~~~~~~~~
1. スクロール範囲の指定
2. スクロールした時の座標の計算が可笑しい?
3. スクロールバーの謎
4. OnMouseWheel を拾うには

5. 自動スクロール
　* 展開した時に、TreeView に入りきらない場合には、親ノードが一番上に為る様にスクロールする
　　→WinForms ではスクロールする様になっているが、
　　スクロールしない方が分かりやすいかも知れない。
　　
　　現状ではスクロールしない様になっている。
　　プロパティでスクロールを有効化できる様にすると言うのも一つの手である。
　　
  * 自動横スクロール抑止 ■
    現在はフォーカスノードが見える様にスクロールを自動で実行する様になっている。
    特に長い名前を持ったノードの場合には、名前が出来るだけ沢山見える様に、
    横にスクロールもする様になっている。
    然し、横にスクロールされると、ツリーを言ったり来たりする時の操作が面倒になる。
    →プロパティで横にスクロールするのを許可・不許可で選択できる様にするか?

計画2. 再描画の最適化
~~~~~~~~~~~~~~~~~~~~~

計画3. Drag & Drop
~~~~~~~~~~~~~~~~~~
  1. 複数選択 ■■
    * Shift や Ctrl 等の修飾子を押しながら操作した時の動作が、
      マウスで操作した時と同じになっていてこれはキーボードでは直感的でない。
  2. [問題] [完]
  3. DragOver に対する処理
    
  * ドラッグが端に近付いた時の自動スクロール ■
    ドラッグが TreeView の端に近付いた時、自動でスクロールするようにする。
    
    その時は、ReversibleArea に注意する。
    スクロールと共に bitblt すると反転した領域がずれてしまう。
    従って、スクロールを実行する前に dropArea.Clear() して、
    スクロールが終わった後に再度 dropArea.Reverse() する様にするのが良いだろう。
  * 右クリックによるドラッグに対応する。 ■

計画4. 個々のノードの表示
~~~~~~~~~~~~~~~~~~~~~~~~~
1. ± の表示の管理
  * ± の管理と ChildIndent の管理を統合した方がよいだろうか?
    →現状では統合された管理方法になっている。

2. アイコンに関して
　* Icon の管理
    現在、Icon と IconSize を別々に管理しているがこれは扱いにくい。
    ×IconSize が時々刻々と変わる様な Icon を実装したいかも知れない。
      その時には、Icon 側で IconSize を管理していた方が良い。
    ○表示の仕方を変えた場合に、アイコンの大きさが変わる事もある。
      この時に全てのアイコンを初期化し直すのは非効率的である。
      この視点だと、アイコンの大きさは飽くまで TreeNode の方で管理するのが良い。
      →描画する際に TreeNode も渡すのでその時に表示の仕方の設定を確認するという方法。
      然し、表示の仕方の設定をどうせ保持するのであれば IconSize を代わりに保持していても何ら代わりはない。
      表示の仕方の設定をもっと詳しい物にしたいと考えた時にそれは対応すれば良い?
  * アイコンのアニメーション ■
    Icon にアニメーション機能を付けても良い。
    この為には、Node にフレームの変化を伝達する手段が必要である。
    然し、Icon を参照しているノードは一般に複数あり得る。
    故に、TreeView に伝達して、再描画を実行する様にすると良いかも知れない。
    勿論、その場合には、再描画はアイコンの部分だけで充分である。

3. 他
  * IsEnabled の際の表示 (灰色表示) ■
  * Focused の際の表示 (実装依存) ■
  
計画5. ListView 表示?
~~~~~~~~~~~~~~~~~~~~~

初期案:

  TreeView としての表示と ListView (詳細表示) の両方を表示できると便利。
  現在の実装の TreeView の部分が詳細表示の一番左に対応して、
  それ以外の部分が ListView に拡張する上で必要な部分。
  所で、TreeView の部分は必ずしも一番左に位置していなくても良いかも知れない。
  一番左に現在の状態を表す細い枠があっても良い。
  Thunderbird のメール一覧画面なんかはそうなっている気がする。例えば:
  ┌─┬───────┬───┬────┬───┬──┐
  │他│TreeView　部分│ 他2　│　他3 　│ 他4　│他5 │
  
  以降、TreeView の部分を "Tree領域" と呼び、他の詳細表示の項目の部分を "副領域" と呼ぶ事にする。
  
  
  考慮するべき点は:
  * 指定した点から TreeNode への座標変換で詳細表示部分を考慮に入れる事
    これは、先ず初めに横位置で指定した点が Tree領域に属するか副領域に属するかを決定する。
    Tree領域にあった場合には通常と同じように計算を実行すれば良い。
    副領域にあった場合の計算は Tree領域の時の計算を簡単化するだけでできる。
    
    戻り値の TreeNodeHitType には、横位置として新しく副領域 Subitem 等という物を追加すればよい。
    Subitem のインデックスは上位ビットか何処かに記録する。
    このインデックスは現在表示している副領域の中で左から何番目に位置する物かを指定する物である。
    この変更に伴って、HitType を条件分岐に用いている箇所では
    適切に領域番号の格納された上位ビットをマスクで消去しなければならない。
  * 表示の時
    先ず初めに Tree領域と副領域を分割、
    Tree 領域を描画して、それから副領域を描画して…というのを繰り返せばよい。
    その為に、TreeView インスタンスは、
    現在の領域の区切方についての情報を保持していなければならない。
  * Drag&Drop
    これは簡単かも。特に Tree領域の中だけで有効とか言う設計にしても OK。
  * TreeNode 自体の拡張
    TreeNode に副項目を取得する為の関数、或いは何らかのコレクションを追加する。
    副項目は画面の上での順番や表示非表示を切り替える事ができる様にしたいので、
    表示の時のインデックスでは管理しない。
    代わりに何か ID となる様な文字列を使うと良いのではないかと考えている。
    例えば "mwg.Application.Explorer.Filesize" 等の様に。
    
    更に、副項目クラスを作成して、
    副項目自体に Draw や OnClick 等の操作に対する処理をさせる。
    但し、デフォルトでは TreeView に委譲する形で実装を行う。
      class TreeNodeSubitem{
        public virtual void Draw(...){ this.node.DrawSubitem(this.id,...); }
      }
      class TreeNode{
        public virtual void DrawSubitem(string id,...){ 描画処理 }
      }
    特別な副項目を用意したい場合には、override すれば良いだろう。
      class TreeNodeSubitem{
        public override void Draw(...){ 特別の描画 }
      }
    
    或いは副項目の為に必ず Subitem のクラスインスタンスを用意するのが大変という場合には、
    任意のオブジェクトでも良いという事にする。例えば、生の文字列や整数など。
    この場合、オブジェクトが TreeNodeSubitem の場合には TreeNodeSubitem の Draw 関数を呼び出し、
    それ以外の場合には自動的に TreeNode に委譲を行うという事にすれば良い。
  * 選択機能は今のままでよい。
    個々の副項目まで選択できなくて良い。
    TreeNode は副項目も含めてまとめて選択される。
    
実装案2:

  或いは、TreeView 自体は TreeNode の中の構造がどうなっているかについては関知していないので、
  TreeNode を派生させて副項目を表示できる様に拡張してしまうと言うのも手かも知れない。
  その場合は、ちょっと実装が汚くなってしまうかも知れないが、
  1. 現状の TreeView/TreeNode の実装に手を入れなくて済むという点、
  2. 更に、TreeNode 毎に副項目の表示の仕方を自由に変更できる点
  等の利点がある。2 に関してはそれが便利なのかどうかは分からないが。
  例えば、或るノードに関しては副項目1と副項目2のセルを結合して表示する等…。
  
  TreeListView view=this.View as TreeListView;
  if(view!=null)
    foreach(TreeListRegion r in view.regions){
      if(r.IsTreeRegion)
        ProcessTreeRegion(...);
      else
        ProcessSubRegion(r.subitemId,...);
    }
  else
    ProcessTreeRegion(...);
  等と実装すれば OK。
  
  と思ったが、案外面倒かも知れない。
  というのも親 TreeView が +- のインデントに従って、
  あらゆる処理を shift して TreeNode に伝達するから。
  副項目も一緒に shift されては困るので、
  shift する前の情報も手に入れたいが…。
  確実に正確な shift 量を簡単に取得できるのであれば、この方針で良い?
  と思ったけれど描画に際しては Graphics の領域が勝手に Content に狭められて送られてくるし、
  やはり色々と面倒な点が多すぎる気がする。
  
  やはりこの方針は没か…??
  
  
  
現状の TreeView 機能一覧
  TreeView
    DefaultNodeParams .. ノード共通設定。各ノードはこの設定か、親の設定か、独自設定を使用。
    選択機能
      MultiSelect
      FocusedNode
      SelectedNodes
      

他
~~
1. 状態に関して
	IsSelected
	IsActive (→ IsFocused に変更)
	  この二つは TreeView の方で管理を行うべきである。
	  (描画の際にこのプロパティを問い合わせる必要がある。)
	
	IsEnabled は "親が true" 且つ自分が true の時に true となるべき
		→IsEnabled を利用する時に親を調べる様にすれば良い。
		  (その時には、親はそのまた親を参照して IsEnabled を決定しているわけではないので、
		  先祖まで遡って調べなければならない。)
	　→本当にそう振る舞う必要があるのか? 親が Disabled でも子が Disabled で或る必要はないのではないか?
	CheckBox でなくて Option として表示・管理するモード

2. Specialized TreeNode
	TreeNodeReference
		現在の設計だと一つのノードは一つの場所にしか存在出来ない。
		TreeNodeReference はノードのショートカットの様な物。
		複数のノードの子ノードに登録したい時には、一つだけ実体を登録して、
		他は Reference で管理する事とする。

	Xml による初期化
	
3. キーボード操作
  * 上下左右ボタンで移動・展開・縮小を操作できる様にする
    >上下左右のボタンには対応した。
    >[Home][End] ボタンにも対応した。
    [PgDown][PgUp] には未対応

4. 最適化
  ○ExtraMemberCache のキーに string を使うのは非効率的。
  何故なら GetHashCode で全ての文字要素を操作するから。
  object にして置けば、そのアドレスから計算されるであろう。
  (その際には、キーとして指定するオブジェクトも new object() 等で作成した物にする。
  string で指定したのだったら結局 string.GetHashCode が呼び出されるので意味がない。)

  然しそうすると今度は Serialize がうまく行かなくなる。
  キーにするのは、静的に値の変わらない物であるべきである。
  その為、シリアライズの際に限っては文字列に変更する必要がある。

*. 他
  
  * Path による TreeNode の選択
  * プロパティ頁に対応
    TreeView.Nodes
    TreeView.DefaultNodeParams
  * TreeNodeTypeConverter

  * TextTreeNode の表示幅
    現在は MeasureString で計っているが、
    何故か横に余分に長くなっているような気がする。
    余り問題になる事でもないが何故だろうか?
    
  * コンテキストメニューに対応する
    これは IndentArea, CheckBox, Icon, DDBehavior と同様に
    コンテキストメニューを管理するクラスを準備すればよい。
    
  * Win32 コントロールを生成せずに、
    イベントと描画先だけをインターフェースとした場所に貼り付ける機能?
    →これにすると、TreeNode.View 等はコントロールではなくて、
      概念的 TreeView にならざるを得ない。
    
    

